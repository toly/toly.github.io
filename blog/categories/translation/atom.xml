<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Translation | Toly blog]]></title>
  <link href="http://toly.github.io/blog/categories/translation/atom.xml" rel="self"/>
  <link href="http://toly.github.io/"/>
  <updated>2014-03-28T22:16:41+04:00</updated>
  <id>http://toly.github.io/</id>
  <author>
    <name><![CDATA[Toly]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Передовые паттерны проектирования в Python]]></title>
    <link href="http://toly.github.io/blog/2014/03/05/advanced-design-patterns-in-python/"/>
    <updated>2014-03-05T19:56:33+04:00</updated>
    <id>http://toly.github.io/blog/2014/03/05/advanced-design-patterns-in-python</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Перевод статьи <a href="http://pypix.com/python/advanced-data-structures/">Advanced Design Patterns in Python</a></p>
</blockquote>

<p>Цель данной статьи - показать передовые паттерны в Python и лучший способ их использовать. В зависимости от того, что вам нужно от структуры кода, будь то быстрый поиск, постоянство, индексация и т.д., вы можете выбрать оптимальную структуру для работы, и большую часть времени вы будете смешивать их вместе что бы получить логичную и простую для понимания модель данных. Паттерны в Python очень интуитивны с точки зрения синтаксиса и они предлагают большой выбор операций. Это руководство пытается собрать наиболее распространенную и полезную информацию о каждом паттерне, а так же советы о том когда лучше всего использовать тот или иной паттерн.</p>

<!-- more -->

<h2 id="section">Генераторы</h2>

<p>Если вы очень долго используете Python, скорее всего вы слышали о генераторах списков. Они подходят для цикла, блока <strong>if</strong> и способны уместить  все это в одну строку. Другими словами, вы можете отобразить (<strong>map</strong>) и отфильтровать (<strong>filter</strong>) список одним выражением.</p>

<p>Генератор списка состоит из следующих частей:</p>

<ul>
  <li>входная последовательность</li>
  <li>переменная, представляющая элементы входной последовательности</li>
  <li>условие (опционально)</li>
  <li>выходное выражение, полученное из элементов входного списка, которые удовлетворяют условию</li>
</ul>

<p>Допустим, нам нужно получить список всех квадратов целых чисел, которые больше нуля:</p>

<p>``` python
num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = []</p>

<p>for number in num:
    if number &gt; 0:
        filtered_and_squared.append(number ** 2)
print filtered_and_squared</p>

<h1 id="section-1">[1, 16, 100, 4, 9]</h1>
<p>```</p>

<p>Согласитесь, довольно просто? Но это занимает 4-е строчки, 2-у уровня вложенности, и вдобавок мы делаем довольно тривиальную вещь. Вы можете уменьшить количество кода с помощью функций <strong>filter</strong>, <strong>lambda</strong> и <strong>map</strong>:</p>

<p>``` python
num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = map(lambda x: x ** 2, filter(lambda x: x &gt; 0, num))
print filtered_and_squared</p>

<h1 id="section-2">[1, 16, 100, 4, 9]</h1>
<p>```</p>

<p>Теперь код расширяется горизонтально! Что можно сделать, что бы упростить код? Применить генераторы списков.</p>

<p>``` python
num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = [ x**2 for x in num if x &gt; 0]
print filtered_and_squared</p>

<h1 id="section-3">[1, 16, 100, 4, 9]</h1>
<p>```</p>

<p>Генератор списков заключен в квадратные скобки, таким образом, видно что список производится сразу. В этом генераторе списка только один вызов функции и нет вызовов загадочной <strong>lambda</strong> - используется обычный итератор, выходное выражение и опциональное условие.</p>

<p>Но, есть и минусы: результирующий списов вычисляется и сохраняется в память сразу. Это не проблема для небольших списков, наподобие приведенных выше, или даже списков на порядок больших. Но иногда это может быть неэффективно.</p>

<p><strong>Генераторы</strong> выручат и сейчас. Выражение-генератор не загружает весь список в память сразу, а вместо этого создает объект генератора, поэтому за один раз можно получить только один элемент.</p>

<p>Выражения-генераторы имеют синтаксис, похожий на синтаксис генераторов списков, только вместо квадратных скобок - круглые:</p>

<p>``` python
num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = ( x**2 for x in num if x &gt; 0 )
print filtered_and_squared</p>

<h1 id="generator-object-genexpr-at-0x00583e18">&lt;generator object <genexpr> at 0x00583E18&gt;</genexpr></h1>

<p>for item in filtered_and_squared:
    print item</p>

<h1 id="section-4">1, 16, 100 4,9</h1>
<p>```</p>

<p>Это даже немного эффективнее использования генераторов списков. Заменим пример более эффективным кодом:</p>

<p>``` python
num = [1, 4, -5, 10, -7, 2, 3, -1]</p>

<p>def square_generator(optional_parameter):
    return (x ** 2 for x in num if x &gt; optional_parameter)</p>

<p>print square_generator(0)
# &lt;generator object <genexpr> at 0x004E6418&gt;</genexpr></p>

<h1 id="option-i">Option I</h1>
<p>for k in square_generator(0):
    print k
# 1, 16, 100, 4, 9</p>

<h1 id="option-ii">Option II</h1>
<p>g = list(square_generator(0))
print g
# [1, 16, 100, 4, 9]
```</p>

<p>Использование выражения-генератора вероятно более хорошая практика, но вы не увидите разницы в эффективности, если список не очень велик.</p>

<p>Так же, вы можете использовать функцию <strong>zip</strong> для работы с двумя и более элементами за раз:</p>

<p>``` python
alist = [‘a1’, ‘a2’, ‘a3’]
blist = [‘1’, ‘2’, ‘3’]</p>

<p>for a, b in zip(alist, blist):
    print a, b</p>

<h1 id="a1-1">a1 1</h1>
<p># a2 2
# a3 3
```</p>

<p>Пример двухуровневого генератора с использованием <strong>os.walk()</strong>:</p>

<p>``` python
import os
def tree(top):
    for path, names, fnames in os.walk(top):
        for fname in fnames:
            yield os.path.join(path, fname)</p>

<p>for name in tree(‘C:\Users\XXX\Downloads\Test’):
    print name
```</p>

<h2 id="section-5">Декораторы</h2>

<p>Декораторы предоставляют очень удобный метод для добавления функциональности для существующих функций и классов. Похоже на АОП (аспектно-ориентированное программирование) в Java, не так ли? Кроме того, что это проще, а значит мощнее. Например, предположим вам нужно что-либо сделать на точках входа и выхода их функции (защиту, отслеживание, блокирование и др. - стандартные элементы АОП).</p>

<p>Декоратор - это функция, которая обертывает другую функцию: вызывается основная функция и ее результат передается в декоратор. Затем декоратор возвращает функцию, которая заменяет оборачиваемую функцию так как нужно.</p>

<p>``` python
def timethis(func):
    ‘’’
    Decorator that reports the execution time.
    ‘’’
    pass</p>

<p>@timethis
def countdown(n):
    while n &gt; 0:
        n -= 1
```</p>

<p>Символ <strong>@</strong> указывает на применение декоратора.</p>

<p>Теперь давайте реализуем код декоратора. Здесь мы фактически используем код декорируемой функции:</p>

<p>``` python
import time
from functools import wraps</p>

<p>def timethis(func):
    ‘’’
    Decorator that reports the execution time.
    ‘’’
    @wraps(func)
    def wrapper(<em>args, **kwargs):
        start = time.time()
        result = func(</em>args, **kwargs)
        end = time.time()
        print(func.<strong>name</strong>, end-start)
        return result
    return wrapper</p>

<p>@timethis
def countdown(n):
    while n &gt; 0:
        n -= 1</p>

<p>countdown(100000)</p>

<h1 id="countdown-0006999969482421875">(‘countdown’, 0.006999969482421875)</h1>
<p>```</p>

<p>Когда вы пишете код вроде этого:</p>

<p><code>python
@timethis
def countdown(n):
</code></p>

<p>это то же самое, как если бы выполнялось следующее</p>

<p>``` python
def countdown(n):
	…</p>

<p>countdown = timethis(countdown)
```</p>

<p>Код внитри декоратора обычно включает в себя создание новой функции, которая принимает любые аргументы (с использованием *args и **kwargs) как показано в случае с функцией wrapper в этом примере. Внутри этой функции вы принимает входные аргументы оригинальной функции и возвращаете результат. Однако, вы так же можете разместить там дополнительный код (например, замер времени и т.д.). Таким образов созданная функция-обертка возвращает результат, как если бы это была оригинальная функция.</p>

<p>Давайте рассмотрим другой пример:</p>

<p><code>python
@decorator
def function():
    print("inside function")
</code></p>

<p>Когда компилятор проходит этот код, <code>function()</code> компилируется и получившийся объект-функция передается в код декоратора <code>decorator</code>, который создает из нее другой объект-функцию, что бы заменить первоначальную функцию <code>function()</code>.</p>

<p>Как выглядит код декоратора? В основном в примерах показывают его как функцию, но я обнаружил, что легче разобраться в декораторах с помощью классов. Кроме того, классы дают больше возможностей.</p>

<p>Единственное ограничение на результат возвращаемый декоратором, это то, что он может быть вызван как функция - т.е. что его можно вызвать. Таким образом, любые классы, которые мы используем в качестве декораторов должны быть с методом <code>__call__</code>.</p>

<p>Что должен делать декоратор после вызова? Вообще-то, все что угодно, но обычно ожидается, что будет использован код оригинальной функции. Однако, это не обязательно:</p>

<p>``` python
class decorator(object):</p>

<pre><code>def __init__(self, f):
    print("inside decorator.__init__()")
    f() # Prove that function definition has completed
 
def __call__(self):
    print("inside decorator.__call__()")
</code></pre>

<p>@decorator
def function():
    print(“inside function()”)</p>

<p>print(“Finished decorating function()”)</p>

<p>function()</p>

<h1 id="inside-decoratorinit">inside decorator.<strong>init</strong>()</h1>
<p># inside function()
# Finished decorating function()
# inside decorator.<strong>call</strong>()
```</p>

<p>Практический пример:</p>

<p>``` python
def decorator(func):
    def modify(<em>args, **kwargs):
        variable = kwargs.pop(‘variable’, None)
        print variable
        x,y=func(</em>args, **kwargs)
        return x,y
    return modify</p>

<p>@decorator
def func(a,b):
    print a<strong>2,b</strong>2
    return a<strong>2,b</strong>2</p>

<p>func(a=4, b=5, variable=”hi”)
func(a=4, b=5)</p>

<h1 id="hi">hi</h1>
<p># 16 25
# None
# 16 25
```</p>

<h2 id="contextlib--">ContextLib (менеджеры контекста)</h2>

<p>Модуль <strong>contextlib</strong> содержит средства для работы с менеджерами контекста и оператором <strong>with</strong>. Обычно, что бы написать менеджер контекста, вы определяете класс с методами <code>__enter__()</code> и <code>__exit__()</code>. Например:</p>

<p>``` python
import time
class demo:
    def <strong>init</strong>(self, label):
        self.label = label</p>

<pre><code>def __enter__(self):
    self.start = time.time()
 
def __exit__(self, exc_ty, exc_val, exc_tb):
    end = time.time()
    print('{}: {}'.format(self.label, end - self.start)) ```
</code></pre>

<p>Полный пример:</p>

<p>``` python
import time</p>

<p>class demo:
    def <strong>init</strong>(self, label):
        self.label = label</p>

<pre><code>def __enter__(self):
    self.start = time.time()
 
def __exit__(self, exc_ty, exc_val, exc_tb):
    end = time.time()
    print('{}: {}'.format(self.label, end - self.start))
</code></pre>

<p>with demo(‘counting’):
    n = 10000000
    while n &gt; 0:
        n -= 1</p>

<h1 id="counting-136000013351">counting: 1.36000013351</h1>
<p>```</p>

<p>Менеджер контекста “включается” оператором <strong>with</strong>. Возвращаемый объект будет использоваться в контексте. Метод <code>__enter__()</code> выполняется, когда поток управления входит в блок кода внутри оператора <strong>with</strong>. Когда поток управления покидает блок кода внутри <strong>with</strong>, вызывается метод <code>__exit__()</code>, что бы очистить используемые ресурсы.</p>

<p>Заново напишем исходный пример, используя декоратор <code>@contextmanager</code> из модуля <strong>contextlib</strong>:</p>

<p>``` python
from contextlib import contextmanager
import time</p>

<p>@contextmanager
def demo(label):
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(‘{}: {}’.format(label, end - start))</p>

<p>with demo(‘counting’):
    n = 10000000
    while n &gt; 0:
        n -= 1</p>

<h1 id="counting-132399988174">counting: 1.32399988174</h1>
<p>```</p>

<p>В функции <code>demo(label)</code> весь код до оператора <strong>yield</strong> исполняется как метод менеджера контекста <code>__enter__()</code>. Весь код после оператора <strong>yield</strong> выполняется как метод <code>__exit__()</code>. Если в блоке внутри <strong>with</strong> возникнет исключение, оно “объявится” на месте оператора <strong>yield</strong>.</p>

<h2 id="section-6">Дескрипторы</h2>

<p>Дескрипторы определяют как осуществляется доступ к аттрибутам объекта. Дескриптор является способом изменить то, что происходит, когда вы обращаетесть к аттрибуту объекта.</p>

<p>Что бы создать дескриптор, нужно определить хотя бы один из следующих трех методов. Обратите внимание, что <code>instance</code> - это объект, к аттрибуту которого меняется доступ, а <code>owner</code> - класс, для которого дескриптор является аттрибутом.</p>

<p><code>__get__(self, instance, owner)</code> - вызывается, когда запрашивается аттрибут (value = obj.attr); то что возвращается будет передано коду, запрашивающему аттрибут.</p>

<p><code>__set__(self, instance, value)</code> - вызывается, когда аттрибуту устанавливается значение (obj.attr = value); ничего не возвращает.</p>

<p><code>__delete__(self, instance)</code> - вызывается, когда аттрибут объекта удалаяется (del obj.attr)</p>

<p>Ленивые аттрибуты:</p>

<p>``` python
import weakref</p>

<p>class lazyattribute(object):
    def <strong>init</strong>(self, f):
        self.data = weakref.WeakKeyDictionary()
        self.f = f
    def <strong>get</strong>(self, obj, cls):
        if obj not in self.data:
            self.data[obj] = self.f(obj)
        return self.data[obj]</p>

<p>class Foo(object):
    @lazyattribute
    def bar(self):
        print “Being lazy”
        return 42</p>

<p>f = Foo()</p>

<p>print f.bar
# Being lazy
# 42</p>

<p>print f.bar
```</p>

<blockquote>
  <p>Дескрипторы - это обобщение концепции связанных методов, лежащих в основе реализации классических классов. В классических классах, когда аттрибут экзампляра не найден в словаре экземпляра, поиск продолжается в словаре класса, а затем рекурсивно в словарях базовых классов. Когда аттрибут найден в словаре класса (не в словаре экземпляра), интерпретатор проверяет, является ли найденный объект функцией. Если это так, то возвращается не найденный объект, а обернутый объект, который действует как каррированая функция. Когда вызывается обернутый объект, он вызывает оригинальную функцию с экземпляром в качестве одного из аргументов.</p>
</blockquote>

<p>Как отмечено выше, дескрипторы закрепляются за классом, и когда осуществляется доступ к аттрибуту, автоматически вызываются специальные методы, причем используемый метод зависит от того, какой типа доступа осуществляется.</p>

<h2 id="section-7">Метаклассы</h2>

<p>Метаклассы предлагают мощный способ изменить поведение классов в Python.</p>

<p>Метакласс определяется как “класса класса”. Любой класс, экземпляры которого являются сами классы, является метаклассом.</p>

<p>``` python
class demo(object):
    pass</p>

<p>obj = demo()</p>

<p>print “Class of obj is {0}”.format(obj.<strong>class</strong>)
print “Class of obj is {0}”.format(demo.<strong>class</strong>)</p>

<h1 id="class-of-obj-is-class-maindemo">Class of obj is &lt;class ‘<strong>main</strong>.demo’&gt;</h1>
<p># Class of obj is &lt;type ‘type’&gt;
```</p>

<p>Мы создали класс и объект этого класса. Запросив у экземпляра аттрибут <code>__class__</code>, мы увидели, что это <code>demo</code>. Дальше интереснее. Что такое класс <code>demo</code>? У него мы тоже можем посмотреть аттрибут <code>__class__</code> - это <code>type</code>.</p>

<p>Итак, <code>type</code> - это класс классов в Python. Другими словами, в приведенном выше примере <code>obj</code> - это объект класса <code>demo</code>, сам класс <code>demo</code> является объектом <code>type</code>.</p>

<p>Таким образом это делает <code>type</code> метаклассом - в действительности наиболее часто используемый метакласс в Python, т.к. это дефолтный метакласс для всех классов.</p>

<p>Т.к. метакласс - это класс классов, он используется для создания классов (тех, что создают объекты). Но подождите, не мы ли создаем классы, когда определяем их стандартным способом? Все верно, но то что делает Python “под капотом” выглядит так:</p>

<ul>
  <li>когда встречается определение класса, Python собирает аттрибуты (включая методы) в словарь</li>
  <li>когда определение класса закончилось, Python определяет для него метакласс; давайте назовем его <em>Meta</em></li>
  <li>после Python выполняет <code>Meta(name, bases, dct)</code>, где:
    <ul>
      <li><code>Meta</code> - это метакласс, поэтому этот вызов создает его экземпляр</li>
      <li><code>name</code> - это имя только что созданного класса</li>
      <li><code>bases</code> - это кортеж базовых классов</li>
      <li><code>dct</code> - словарь, связывающий названия аттрибутов с объектами; в нем перечислены все аттрибуты класса</li>
    </ul>
  </li>
</ul>

<p>Как определить какой метакласс у класса? Если у класса (или один из его базовых классов) имеет аттрибут <code>__metaclass__</code>, то он считается метаклассом. В противном случае, метаклассом является <strong>type</strong>.</p>

<h2 id="section-8">Паттерны</h2>

<p><strong>“Проще просить прощения, чем разрешения”</strong></p>

<p>Один из принципов Python - “Проще просить прощения, чем разрешения”. В отличие от подхода “семь раз отмерь”, этот принцип заключается в том, что сначала вы должны попытаться выполнить действие и если возникает ошибка - реагировать соответствующим образом. Продвинутая обработка исключений в Python поддерживает этот принцип и помогает разрабатывать надежные и устойчивые программы.</p>

<p><strong>Синглтон (одиночка)</strong></p>

<p>Синглтон - это объекты, предполагающие наличие только одного экземпляра. Python предоставляет несколько путей для реализации синглтонов.</p>

<p><strong>Null object</strong></p>

<p>Null object может быть использован вместо <strong>None</strong>, что бы избежать проверки на None.</p>

<p><strong>Обозреватель</strong></p>

<p>Паттерн обозреватель позволяет нескольким объектам иметь доступ к общим данным.</p>

<p><strong>Конструктор</strong></p>

<p>Параметры конструктора часто назначаются переменным экземпляра. Этот паттерн может заменить много строк ручного присваивания одной строчкой.</p>

<h2 id="section-9">Заключение</h2>

<p>Спасибо за чтение. Оставляйте свои ​​комментарии для дальнейшего обсуждения.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Многопоточность в одну строку]]></title>
    <link href="http://toly.github.io/blog/2014/02/13/parallelism-in-one-line/"/>
    <updated>2014-02-13T13:53:13+04:00</updated>
    <id>http://toly.github.io/blog/2014/02/13/parallelism-in-one-line</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Перевод статьи Криса Кила <a href="https://medium.com/p/40e9b2b36148">Parallelism in one line</a></p>
</blockquote>

<p>Python имеет ужасную репутацию, когда речь идет о возможности параллельных вычислений. Не обращая внимания на типичные рассуждения о его потоках и GIL (который обычно нормально работает), по-моему реальная проблема многопоточности Python не техническая, а педагогическая. Распространенные руководства о библиотеках <strong>threading</strong> и <strong>multiprocessing</strong> в целом неплохие, но тяжеловаты для понимания. Они начинаются с глубоких вещей, и заканчиваются до просто применяемых практик.</p>

<!-- more -->

<h2 id="section">Традиционный пример</h2>

<p>Беглое ознакомление с первыми результатами поискового запроса на тему “Python threading tutorial” показывает, что почти каждый из них основан на  использовании какого-либо вспомогательного класса в связке с модулем <strong>Queue</strong>.</p>

<p>Типичный пример многопоточности вида поставщик-потребитель:</p>

<p>``` python
#Example.py
‘’’
Standard Producer/Consumer Threading Pattern
‘’’</p>

<p>import time 
import threading 
import Queue </p>

<p>class Consumer(threading.Thread): 
	def <strong>init</strong>(self, queue): 
		threading.Thread.<strong>init</strong>(self)
		self._queue = queue </p>

<pre><code>def run(self):
	while True: 
		# queue.get() blocks the current thread until 
		# an item is retrieved. 
		msg = self._queue.get() 
		# Checks if the current message is 
		# the "Poison Pill"
		if isinstance(msg, str) and msg == 'quit':
			# if so, exists the loop
			break
		# "Processes" (or in our case, prints) the queue item	
		print "I'm a thread, and I received %s!!" % msg
	# Always be friendly! 
	print 'Bye byes!'
</code></pre>

<p>def Producer():
	# Queue is used to share items between
	# the threads.
	queue = Queue.Queue()</p>

<pre><code># Create an instance of the worker
worker = Consumer(queue)
# start calls the internal run() method to 
# kick off the thread
worker.start() 

# variable to keep track of when we started
start_time = time.time() 
# While under 5 seconds.. 
while time.time() - start_time &lt; 5: 
	# "Produce" a piece of work and stick it in 
	# the queue for the Consumer to process
	queue.put('something at %s' % time.time())
	# Sleep a bit just to avoid an absurd number of messages
	time.sleep(1)

# This the "poison pill" method of killing a thread. 
queue.put('quit')
# wait for the thread to close down
worker.join()
</code></pre>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
	Producer()
```</p>

<p>Мда… Просматриваются Java’вские корни.</p>

<p>Что ж, я не хочу, что бы у вас создалось впечатление, будто схема поставщик-потребитель плоха для многопоточной разработки - это определенно не так. На самом деле такой способ хорошо подходит для решения множества задач. Однако, я думаю, что это не подходит для ежедневного применения.</p>

<h2 id="section-1">Проблемы (на мой взгляд)</h2>

<p>Во-первых, вам нужен шаблонный класс, который делает то, что нужно. Во-вторых, вам нужно организовать очередь, согласно которой будут обрабатываться объекты; и наконец, вам нужны методы для входа в очередь и выхода из очереди что бы делать реальную работу (скорее всего, с участием другой очереди, если вы хотите получать обратную связь или сохранять результаты работы).</p>

<h3 id="section-2">Больше воркеров, больше задач</h3>

<p>Следующее, что вы вероятно сделаете, это пулл воркеров, что бы выжать из Python больше производительности. Ниже приводится измененный код примера из превосходного <a href="http://www.ibm.com/developerworks/aix/library/au-threadingpython/">руководства</a> по многопоточности от IBM. Это достаточно распространенный сценарий, когда вы распределяете задачи получения веб-страниц на несколько потоков.</p>

<p>``` python
#Example2.py
‘’’
A more realistic thread pool example 
‘’’</p>

<p>import time 
import threading 
import Queue 
import urllib2 </p>

<p>class Consumer(threading.Thread): 
	def <strong>init</strong>(self, queue): 
		threading.Thread.<strong>init</strong>(self)
		self._queue = queue </p>

<pre><code>def run(self):
	while True: 
		content = self._queue.get() 
		if isinstance(content, str) and content == 'quit':
			break
		response = urllib2.urlopen(content)
	print 'Bye byes!'
</code></pre>

<p>def Producer():
	urls = [
		‘http://www.python.org’, ‘http://www.yahoo.com’
		‘http://www.scala.org’, ‘http://www.google.com’
		# etc.. 
	]
	queue = Queue.Queue()
	worker_threads = build_worker_pool(queue, 4)
	start_time = time.time()</p>

<pre><code># Add the urls to process
for url in urls: 
	queue.put(url)	
# Add the poison pillv
for worker in worker_threads:
	queue.put('quit')
for worker in worker_threads:
	worker.join()

print 'Done! Time taken: {}'.format(time.time() - start_time)
</code></pre>

<p>def build_worker_pool(queue, size):
	workers = []
	for _ in range(size):
		worker = Consumer(queue)
		worker.start() 
		workers.append(worker)
	return workers</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
	Producer()
```</p>

<p>Работает отлично, но посмотрите на весь этот код! Здесь методы инициализации, списки потоков для отслеживания работы, и что хуже всего, если вы склонны к обработке блокировок как и я, куча вызовов метода <strong>join</strong>. А впоследствии будет еще сложнее!</p>

<p>А что было сделано? Да практически ничего. Вышеприведенный код представляет собой хрупкую конструкцию. Это внимательное следование шаблону, это высокая вероятность ошибок (я даже забыл вызвать метод <em>task_done()</em> в объекте очереди пока писал это), и это писать много кода и получать мало функционала. К счастью, есть гораздо лучший способ.</p>

<h2 id="map">Знакомьтесь: <strong>Map</strong></h2>

<p><em>Map</em> - это класная маленькая функция, а главное, проста для распараллеливания вашего Python кода. Для тех, кто не вкурсе, <em>map</em> заимствована из функциональных языков, вроде Lisp’а. Это функция, которая применяет другую функцию к последовательности, например:</p>

<p><code>python
urls = ['http://www.yahoo.com', 'http://www.reddit.com']
results = map(urllib2.urlopen, urls)
</code></p>

<p>Этот код применяет метод <em>urlopen</em> к каждому элементу переданной последовательности и сохраняет полученные результаты в список. Это более-менее эквивалентно следующему коду:</p>

<p><code>python
results = []
for url in urls: 
    results.append(urllib2.urlopen(url))
</code></p>

<p>Функция <em>map</em> управляет итерацией последовательности, применяет нужную функцию, и в конце сохраняет все получившиеся результаты в список.</p>

<p>Почему это имеет значение? Потому, что используя определенные библиотеки, <em>map</em> делает использование многопоточности тривиальным!</p>

<p>Функция <em>map</em> с поддержкой многопоточности присутствует в двух библиотеках: <strong>multiprocessing</strong>, а так же малоизвестная, но неменее замечательная - <strong>multiprocessing.dummy</strong>.</p>

<p><em>Отступление:</em> Что это? Никогда не слышал о многопоточном клоне библиотеки <strong>multiprocessing</strong> под названием <em>dummy</em>? Я тоже не слышал до недавнего времени. Есть всего одно предложение на странице официальной документации библиотеки <strong>multiprocessing</strong>. И это предложение сводится к “Ах да, эта вещь существует”. Это печально, скажуя вам!</p>

<p><strong>multiprocessing.dummy</strong> представляет собой точный аналог модуля <strong>multiprocessing</strong>. Разница лишь в том, что <strong>multiprocessing</strong> работает с процессами, а <strong>multiprocessing.dummy</strong> использует треды (со всеми присущими им ограничениями). Поэтому, все что относится к одной библиотеке, относится и к другой. Это делает переключение между ними довольно простым.</p>

<h2 id="section-3">Приступим</h2>

<p>Для доступа к map-параллельной функции, сперва нужно импортировать модули в которых она содержится и создать пулл:</p>

<p>``` python
from multiprocessing import Pool
from multiprocessing.dummy import Pool as ThreadPool </p>

<p>pool = ThreadPool()
```</p>

<p>Последнее выражение делает то же, что и семистрочная функция <em>build_worker_pool</em> в приведенном ранее примере. А именно, создает кучу доступных воркеров, поготавливает их к выполнению задач, и сохраняет их в переменной, что бы к ним было легко обратиться.</p>

<p>Объекты из пула принимают несколько параметров, но сейчас упоминания стоит только один: <em>processes</em>. Этот параметр устанавливает количество воркеров в пуле. Если оставить это поле пустым, то по умолчанию оно будет равно количеству ядер в вашем процессоре.</p>

<p>В общем случае, если вы используете многопроцессовый пулл для ядро-раздельных задач, то больше ядер означает большуую скорость (я говорю это с многочисленными оговорками). Однако, когда речь идет о многопоточной обработке и делах связанных с сетью, это не так, и будет хорошей идеей поэксперементировать с размером пула.</p>

<p><code>python
pool = ThreadPool(4) # Sets the pool size to 4
</code></p>

<p>Если вы запустите слишком много потоков, вы затратите больше времени на переключения между ними, чем на полезную работу, так что в этом случае неплох поизменять параметры до тех пор, пока не найдет оптимальный вариант для вашей задачи.</p>

<p>Итак, теперь, когда созданы воркеры и простой способ распараллеливания в наших руках, давайте перепишем загрузку веб-страниц из предыдущего примера.</p>

<p>``` python
import urllib2 
from multiprocessing.dummy import Pool as ThreadPool </p>

<p>urls = [
	‘http://www.python.org’, 
	‘http://www.python.org/about/’,
	‘http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html’,
	‘http://www.python.org/doc/’,
	‘http://www.python.org/download/’,
	‘http://www.python.org/getit/’,
	‘http://www.python.org/community/’,
	‘https://wiki.python.org/moin/’,
	‘http://planet.python.org/’,
	‘https://wiki.python.org/moin/LocalUserGroups’,
	‘http://www.python.org/psf/’,
	‘http://docs.python.org/devguide/’,
	‘http://www.python.org/community/awards/’
	# etc.. 
	]</p>

<h1 id="make-the-pool-of-workers">Make the Pool of workers</h1>
<p>pool = ThreadPool(4) </p>

<h1 id="open-the-urls-in-their-own-threads">Open the urls in their own threads</h1>
<p># and return the results
results = pool.map(urllib2.urlopen, urls)</p>

<h1 id="close-the-pool-and-wait-for-the-work-to-finish">close the pool and wait for the work to finish</h1>
<p>pool.close() 
pool.join() 
```</p>

<p>Посмотрите на это! Код который на самом деле работает занимает 4 строки, 3 из которых формальны. Функция <strong>map</strong> сделала то же, что и предыдущий код в 40 строк с такой легкостью! Для проверки я испробовал оба подхода и попробовал различные размеры пула.</p>

<p>``` python
results = [] 
for url in urls:
	result = urllib2.urlopen(url)
	results.append(result)</p>

<h1 id="versus--------">——- VERSUS ——-</h1>

<h1 id="pool--------">——- 4 Pool ——-</h1>
<p>pool = ThreadPool(4) 
results = pool.map(urllib2.urlopen, urls)</p>

<h1 id="pool---------1">——- 8 Pool ——-</h1>
<p>pool = ThreadPool(8) 
results = pool.map(urllib2.urlopen, urls)</p>

<h1 id="pool---------2">——- 13 Pool ——-</h1>
<p>pool = ThreadPool(13) 
results = pool.map(urllib2.urlopen, urls)
```</p>

<h2 id="section-4">Результаты:</h2>

<p><code>
 						Single thread:  14.4 Seconds 
 						       4 Pool:   3.1 Seconds
 						       8 Pool:   1.4 Seconds
 						      13 Pool:   1.3 Seconds
</code></p>

<p>Потрясающе! Это так же показывает, почему полезно поэкспериментировать с размером пула. Любой пулл с более чем 9 воркерами быстро приводит в падению прироста скорости (на этом компе).</p>

<h1 id="section-5">Реальный пример №2</h1>
<p>Создание миниатюр для тысяч изображений</p>

<p>Теперь давайте сделаем что-нибудь процесорно-раздельное! Довольно распространенная задача у меня на работе - это обработка больших коллекций картинок. Одна из таких задач - создание миниатюр. И это можно распараллелить.</p>

<h2 id="section-6">Простая однопроцессная реализация</h2>

<p>``` python
import os
from PIL import Image</p>

<p>SIZE = (75, 75)
SAVE_DIRECTORY = ‘thumbs’</p>

<p>def get_image_paths(folder):
    return (os.path.join(folder, f)
            for f in os.listdir(folder)
            if ‘jpeg’ in f)</p>

<p>def create_thumbnail(filename):
    im = Image.open(filename)
    im.thumbnail(SIZE, Image.ANTIALIAS)
    base, fname = os.path.split(filename)
    save_path = os.path.join(base, SAVE_DIRECTORY, fname)
    im.save(save_path)</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    folder = os.path.abspath(‘images_path’)
    os.mkdir(os.path.join(folder, SAVE_DIRECTORY))</p>

<pre><code>images = get_image_paths(folder)

for image in images:
    create_thumbnail(image) ```
</code></pre>

<p>Пример несколько адаптирован, но по сути происходит следующее: каталог с изображениями передается в программу, потом из каталога выбираются все картинки, и наконец создаются миниатюры и сохраняются в отдельный каталог.</p>

<p>На моем компьютере это выполняется за 27.9 секунд для порядка 6000 изображений.</p>

<p>Если мы заменим цикл <strong>for</strong> параллельной функцией <strong>map</strong>:</p>

<p>``` python
import os
from PIL import Image
from multiprocessing import Pool</p>

<p>SIZE = (75, 75)
SAVE_DIRECTORY = ‘thumbs’</p>

<p>def get_image_paths(folder):
    return (os.path.join(folder, f)
            for f in os.listdir(folder)
            if ‘jpeg’ in f)</p>

<p>def create_thumbnail(filename):
    im = Image.open(filename)
    im.thumbnail(SIZE, Image.ANTIALIAS)
    base, fname = os.path.split(filename)
    save_path = os.path.join(base, SAVE_DIRECTORY, fname)
    im.save(save_path)</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    folder = os.path.abspath(‘images_path’)
    os.mkdir(os.path.join(folder, SAVE_DIRECTORY))</p>

<pre><code>images = get_image_paths(folder)

pool = Pool()
pool.map(create_thumbnail, images)
pool.close()
pool.join() ```
</code></pre>

<p><strong>5.6 секунд!</strong></p>

<p>Это серъезный прирост для изменения всего лишь нескольких строчек кода. Продакшен версия еще быстрее, так как в ней разделены процессорные задачи и задачи ввода-вывода на отдельные процессы и потоки - обычный рецепт для кода с учетом блокировок.</p>

<p>Так что, так. Распараллеливание в одну (почти) строку.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Начиная Python-проект: The Right Way]]></title>
    <link href="http://toly.github.io/blog/2014/02/09/starting-a-python-project-the-right-way/"/>
    <updated>2014-02-09T21:33:26+04:00</updated>
    <id>http://toly.github.io/blog/2014/02/09/starting-a-python-project-the-right-way</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Достаточно вольный (настолько вольный, что отсутствуют два абзаца и изменен код) перевод статьи Джефа Кнаппа </p>

  <p><a href="http://www.jeffknupp.com/blog/2014/02/04/starting-a-python-project-the-right-way/">Starting A Python Project The Right Way</a></p>
</blockquote>

<p>Если вы подобны большинству начинающих python-программистов, вы вероятно в состоянии представить себе работу приложения целиком, но когда приходит время начать писать код и перед вами пустое окно редактора, вы чувствуете себя потерянным и подавленным. В этой статье я опишу метод, который использую когда начинаю писать программу с нуля. К концу статьи у вас будет хороший план для начала разработки любого приложения.</p>

<!-- more -->

<h2 id="section">Установка</h2>

<p>До того как написать хоть строчку кода, первое что я делаю - создаю <em>виртуальное окружение</em>. Что такое виртуальное окружение? Это установка python отдельно от остальной части системы (и дефолтного pythona’а). Какая от этого польза? Представьте себе, что у вас есть два проекта, над которыми вы работаете. Если оба испольузют какую-либо библиотеку (например, <strong>requests</strong>), и в одном из проектов используется старая версия (которую нельзя корректно обновить, т.к. другие библиотеки используют старую версию <strong>requests</strong>), как вы сможете использовать новую версию <strong>requests</strong> в другом проекте? С помощью виртуального окружения.</p>

<p>Для начала установите <strong>virtualenvwrapper</strong> (обертка над фантастическим пакетом <strong>virtualenv</strong>). Добавьте в ваш <strong>.bashrc</strong> строчку <code>/usr/local/bin/virtualenvwrapper.sh</code> и перезагрузите свой профиль с помощью <strong>source</strong>:</p>

<pre><code>source ~/.bashrc
</code></pre>

<p>Теперь у вас должна появиться команда <strong>mkvirtualenv</strong>, доступная через автодополнение с помощью <em>tab</em>. Если вы используете Python старше версии 3.3, виртуальное окружение поддерживает этот язык и установка этого пакета не требуется. <code>mkvirtualenv &lt;my_project&gt;</code> создаст новое виртуальное окружение под названием my_project с уже установленными <strong>pip</strong> и <strong>setuptools</strong>. Для Python 3 требуемые команды выглядят так:</p>

<pre><code>python -m venv &lt;my_project&gt;
source &lt;my_project&gt;/bin/activate
</code></pre>

<p>Теперь когда виртуальное окружение создано, пришло время инициализировать средство управления исходниками. Предполагая что это <strong>git</strong> (ну, потому что он…), введем</p>

<pre><code>git init .
</code></pre>

<p>Так же полезно добавить в <strong>.gitignore</strong> все скомпилированые Python-ом файлы и каталоги <code>__pychache__</code>. Для этого создайте файл <code>.gitignore</code> и поместите в него следующее:</p>

<pre><code>*.pyc
__pycache__
</code></pre>

<p>Теперь подходящее время добавить в проект <strong>README</strong> файл. Даже если вы единственный, кто будет видеть код, это хорошее упражнение для организации ваших мыслей. <strong>README</strong> файл должен описывать что делает проект, его зависимости и как его использовать. Я пишу <strong>README</strong> файлы с использованием разметки <em>Markdown</em>, во-первых потому что GitHub автоматически оформляет любой файл названный <strong>README.md</strong>, а во-вторых потому что я пишу все (!) документы в разметке <em>Markdown</em>.</p>

<p>И наконец, сделайте первый коммит содержащий два файла (<strong>.gitignore</strong>, <strong>README.md</strong>), которые вы только что создали. Для этого введите:</p>

<pre><code>git add .gitignore README.md
git commit -m "initial commit"
</code></pre>

<h2 id="section-1">Каркасы!</h2>

<p>Почти каждое приложение я начинаю одинаково: создаю каркас приложения, состоящий из функций и классов с заполненой документацией, но без реализации. Я считаю, что необходимо сперва вынужденно писать документацию для функции, иначе если я не способен кратко описать что-либо, то у меня нет достаточно мыслей о проблеме.</p>

<p>В качестве примера приложения я использую скрипт, недавно написанный обучаемым во время одного из наших занятий. Цель скрипта - создать csv-файл, содержащий самые кассовые фильмы прошлого года (по версии IMDB) и ключевые слова связанные с этими фильмами на IMDB. Это был довольно простой проект, для того что бы завершить его за одно занятие, но достаточный по сложности, что бы требовать размышлений.</p>

<p>Сперва создайте основной файл, который будет точкой входа в приложение. Я назвал его <strong>imdb.py</strong>. Потом скопируйте следующий код в редактор:</p>

<p>``` python
	““Script to gather IMDB keywords from 2013’s top grossing movies.”””
	import sys</p>

<pre><code>def main():
    """Main entry point for the script."""
    pass

if __name__ == '__main__':
    sys.exit(main()) ```
</code></pre>

<p>Звучит неправдоподобно, но это вполне функциональная программа. Вы можете запустить ее и получить правильный код выхода (т.е. <strong>0</strong>, хотя справедливо отметить, что пустой файл будет так же возвращать правильный код). Затем я делаю заглушки для функций и/или классов, которые по моему мнению будут нужны:</p>

<p>``` python
	“"”Script to gather IMDB keywords from 2013’s top grossing movies.”””
	import sys</p>

<pre><code>URL = "http://www.imdb.com/search/title?at=0&amp;sort=boxoffice_gross_us,desc&amp;start=1&amp;year=2013,2013"

def main():
    """Main entry point for the script."""
    pass

def get_top_grossing_movie_links(url):
    """Return a list of tuples containing the top grossing movies of 2013 and link to their IMDB
    page."""
    pass

def get_keywords_for_movie(url):
    """Return a list of keywords associated with *movie*."""
    pass

if __name__ == '__main__':
    sys.exit(main()) ```
</code></pre>

<p>Выглядит сносно. Отмечу, что обе функции включают параметры (например, <strong>get_keywords_for_movie</strong> принимает параметр <strong>url</strong>). Это может показаться странным для заглушек. Зачем здесь параметры? Аргументация такая же, как и для предварительного документирования заглушек: если я не знаю какие агрументы должна принимать функция, значит я недостаточно об этом думал.</p>

<p>В этом месте я верятно закомичусь, т.к. проделал определенную часть работы, которую не хотел бы потерять. После этого перейдем к реализации. Я всегда начинаю с реализации функции <strong>main</strong>, т.к. “центр” использующий все остальные функции. Вот реализация функции <strong>main</strong> в <strong>imdb.py</strong>:</p>

<p>``` python
	import csv</p>

<pre><code>def main():
    """Main entry point for the script."""
    movies = get_top_grossing_movie_links(URL)
    with open('output.csv', 'w') as output:
        csvwriter = csv.writer(output)
        for title, url in movies:
            keywords = get_keywords_for_movie(
                'http://www.imdb.com{}keywords/'.format(url))
            csvwriter.writerow([title, keywords]) ```
</code></pre>

<p>Несмотря на то что <strong>get_top_grossing_movie_links</strong> и <strong>get_keywords_for_movie</strong> не реализованы, я знаю достаточно о том, как их использовать. Функция <strong>main</strong> делает именно то, что мы обсуждали вначале: получает самые кассовые фильмы года и пишет их в csv-файл вместе с их ключевыми словами.</p>

<p>Теперь все что осталось, это реализовать недостающие функции. Любопытно, что даже если мы знаем, что <strong>get_keywords_for_movie</strong> будет вызван после <strong>get_top_grossing_movie_links</strong>, мы можем реализовать их в том порядке, который больше нравится. Это не тот случай, когда пишешь скрипт с нуля и добавляешь функционал в том порядке, в которм идет разработка. Вы были бы вынуждены полностью написать первую функцию, прежде чем перети ко второй. Тот факт, что мы можем реализовать (и проверить!) функции в любом порядкепоказывает, что они слабо связаны.</p>

<p>Давайте первым реализуем функцию <strong>get_keywords_for_movie</strong>:</p>

<p><code>python
def get_keywords_for_movie(url):
    """Return a list of keywords associated with *movie*."""
    keywords = []
    response = requests.get(url)
    soup = BeautifulSoup(response.text)
    tables = soup.find_all('table', class_='dataTable')
    table = tables[0]
    return [td.text for tr in table.find_all('tr') for td in tr.find_all('td')]
</code></p>

<p>Мы используем библиотеки <strong>requests</strong> и <strong>BeautifulSoup</strong>, поэтому нам нужно установить их через <em>pip</em>.	Теперь можно внести в список зависимостей проекта новые библиотеки: <code>pip freeze requirements.txt</code> и закомитить изменения. Таким образом мы всегда сможем создать виртуальное окружение и установить именно те библиотеки (и версии) которые нужны для запуска приложения.</p>

<p>Наконец напишем реализацию для функции <strong>get_top_grossing_movie_links</strong>:</p>

<p><code>python
def get_top_grossing_movie_links(url):
    """Return a list of tuples containing the top grossing movies of 2013 and link to their IMDB
    page."""
    response = requests.get(url)
    movies_list = []
    for each_url in BeautifulSoup(response.text).select('.title a[href*="title"]'):
        movie_title = each_url.text 
        movies_list.append((movie_title, each_url['href']))
    return movies_list
</code></p>

<p>Вот финальное содержание <strong>imdb.py</strong>:</p>

<p>``` python
““Script to gather IMDB keywords from 2013’s top grossing movies.”””
import sys
import requests
from bs4 import BeautifulSoup
import csv</p>

<p>URL = “http://www.imdb.com/search/title?at=0&amp;sort=boxoffice_gross_us,desc&amp;start=1&amp;year=2013,2013”</p>

<p>def get_top_grossing_movie_links(url):
    “"”Return a list of tuples containing the top grossing movies of 2013 and link to their IMDB
    page.”””
    response = requests.get(url)
    movies_list = []
    for each_url in BeautifulSoup(response.text).select(‘.title a[href*=”title”]’):
        movie_title = each_url.text 
        movies_list.append((movie_title, each_url[‘href’]))
    return movies_list</p>

<p>def get_keywords_for_movie(url):
    “"”Return a list of keywords associated with <em>movie</em>.”””
    keywords = []
    response = requests.get(url)
    soup = BeautifulSoup(response.text)
    tables = soup.find_all(‘table’, class_=’dataTable’)
    table = tables[0]
    return [td.text for tr in table.find_all(‘tr’) for td in tr.find_all(‘td’)]</p>

<p>def main():
    “"”Main entry point for the script.”””
    movies = get_top_grossing_movie_links(URL)
    with open(‘output.csv’, ‘w’) as output:
        csvwriter = csv.writer(output)
        for title, url in movies:
            keywords = get_keywords_for_movie(‘http://www.imdb.com{}keywords/’.format(url))
            csvwriter.writerow([title, keywords])</p>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    sys.exit(main())</p>

<p>```</p>

<p>Приложение, которое начиналось с пустого окна редактора готово. После запуска скрипт сгенерирует <strong>output.csv</strong>, содержащий именно то, что нужно. Для скрипта такого размера я не стал бы писать тесты, т.к. результат работы программы и есть тест. Тем не менее, написание тестов в данном случае возможно (так как наши функции слабо связаны), что бы проверить каждую функцию отдельно (изолированно).</p>

<h2 id="section-2">Заключение</h2>

<p>Надеюсь теперь у вас есть план действий для начала работы над python-проектом с нуля. Не смотря на то, что у каждого есть свой метод начала работы над проектом, скорее всего мой метод подойдет и вам. Как всегда, если у вас есть какие-либо вопросы, не стесняйтесь задавать их в комментариях или напишите мне на jeff@jeffknupp.com.</p>
]]></content>
  </entry>
  
</feed>
